import Papa from "papaparse";
import * as XLSX from "xlsx";
import { Transaction, FieldMapping, ParsedTransaction } from "../types";
import { categorizeTransaction } from "./categoryMappings";

export function parseExcelCSV(
  file: File,
  mapping: FieldMapping
): Promise<{
  transactions: Transaction[];
  parsedData: ParsedTransaction[];
  headers: string[];
}> {
  return new Promise((resolve, reject) => {
    const fileName = file.name.toLowerCase();

    if (fileName.endsWith(".csv")) {
      // Handle CSV files with Papa Parse
      Papa.parse(file, {
        header: false, // Don't use header detection for bank statements
        skipEmptyLines: true,
        complete: (results) => {
          try {
            processRawParseResults(
              results.data,
              mapping,
              file,
              resolve,
              reject
            );
          } catch (error) {
            reject(
              new Error(
                `CSV processing error: ${
                  error instanceof Error ? error.message : "Unknown error"
                }`
              )
            );
          }
        },
        error: (error) => {
          reject(new Error(`CSV parsing error: ${error.message}`));
        },
      });
    } else if (fileName.endsWith(".xlsx") || fileName.endsWith(".xls")) {
      // Handle Excel files with XLSX
      const reader = new FileReader();

      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: "array" });

          // Get the first worksheet
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];

          // Convert to JSON without header detection
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

          if (jsonData.length === 0) {
            reject(new Error("Excel file appears to be empty"));
            return;
          }

          processRawParseResults(jsonData, mapping, file, resolve, reject);
        } catch (error) {
          reject(
            new Error(
              `Excel processing error: ${
                error instanceof Error ? error.message : "Unknown error"
              }`
            )
          );
        }
      };

      reader.onerror = () => {
        reject(new Error("Failed to read Excel file"));
      };

      reader.readAsArrayBuffer(file);
    } else {
      reject(
        new Error("Unsupported file format. Please upload a CSV or Excel file.")
      );
    }
  });
}

function processRawParseResults(
  rawData: any[],
  mapping: FieldMapping,
  file: File,
  resolve: (value: any) => void,
  reject: (reason: any) => void
) {
  try {
    // Find header row using the single starter word
    const headerInfo = findHeaderRowByStarterWord(rawData, mapping);

    if (!headerInfo) {
      reject(
        new Error(
          `Could not find header row with starter word "${mapping.starterWord}". Please check your field mapping or file format.`
        )
      );
      return;
    }

    const { headerRowIndex, headers, columnMapping } = headerInfo;

    console.log("Header detection results:", {
      headerRowIndex,
      headers,
      columnMapping,
      starterWord: mapping.starterWord,
    });

    // Get data rows after header, skipping any separator rows
    const dataStartIndex = headerRowIndex + 1;
    const dataRows = rawData.slice(dataStartIndex).filter((row) => {
      if (!row || !Array.isArray(row)) return false;

      // Skip rows that are separators (all asterisks, dashes, or empty)
      const rowStr = row.join("").trim();
      if (rowStr === "" || /^[\*\-=]+$/.test(rowStr)) return false;

      // Skip summary rows and other non-transaction data
      const lowerRowStr = rowStr.toLowerCase();
      if (
        lowerRowStr.includes("statement summary") ||
        lowerRowStr.includes("opening balance") ||
        lowerRowStr.includes("closing balance") ||
        lowerRowStr.includes("generated by") ||
        lowerRowStr.includes("total") ||
        lowerRowStr.includes("count")
      )
        return false;

      return true;
    });

    console.log("Processing", dataRows.length, "data rows");

    // Convert to object format using column mapping
    const objectData = dataRows.map((row) => {
      const obj: any = {};
      Object.entries(columnMapping).forEach(([fieldName, columnIndex]) => {
        if (columnIndex !== -1) {
          obj[fieldName] = (row as any[])[columnIndex] || "";
        }
      });
      return obj;
    });

    // Filter out rows that don't have essential data
    const validData = objectData.filter((row) => {
      const hasDate =
        row[mapping.dateColumn] &&
        row[mapping.dateColumn].toString().trim() !== "";
      const hasDescription =
        row[mapping.descriptionColumn] &&
        row[mapping.descriptionColumn].toString().trim() !== "";

      // Check for amount data
      let hasAmount = false;
      if (mapping.amountColumn) {
        hasAmount =
          row[mapping.amountColumn] &&
          row[mapping.amountColumn].toString().trim() !== "";
      } else if (mapping.withdrawalColumn || mapping.depositColumn) {
        const withdrawal = row[mapping.withdrawalColumn] || "";
        const deposit = row[mapping.depositColumn] || "";
        hasAmount =
          withdrawal.toString().trim() !== "" ||
          deposit.toString().trim() !== "";
      }

      return hasDate && hasDescription && hasAmount;
    });

    console.log("Found", validData.length, "valid transactions");

    if (validData.length === 0) {
      reject(
        new Error(
          `No valid transaction data found. Expected columns: Date="${
            mapping.dateColumn
          }", Description="${
            mapping.descriptionColumn
          }". Available columns: ${headers.join(", ")}`
        )
      );
      return;
    }

    const transactions: Transaction[] = [];
    const parsedData: ParsedTransaction[] = [];

    validData.forEach((row: any, index: number) => {
      const parseResult = parseTransactionRow(row, mapping, index);
      parsedData.push(parseResult);

      if (parseResult.success) {
        // Enhanced categorization for credits
        let category = categorizeTransaction(parseResult.description);

        // If it's a credit and not already categorized as salary/bonus, mark as Credits
        if (
          parseResult.type === "credit" &&
          !["Salary", "Bonus", "Investment Returns"].includes(category)
        ) {
          category = "Credits";
        }

        const transaction: Transaction = {
          id: `excel-${index}-${Date.now()}`,
          date: parseResult.date,
          description: parseResult.description,
          amount: parseResult.amount,
          type: parseResult.type,
          category: category,
          originalDescription: parseResult.description,
          isManual: false,
          source: file.name.endsWith(".csv") ? "csv" : "excel",
        };
        transactions.push(transaction);
      }
    });

    if (transactions.length === 0) {
      const errorDetails = parsedData
        .filter((p) => !p.success)
        .slice(0, 3)
        .map((p) => p.error)
        .join("; ");

      reject(
        new Error(
          `No valid transactions found. Processed ${parsedData.length} rows. Sample errors: ${errorDetails}`
        )
      );
      return;
    }

    resolve({
      transactions: transactions.sort(
        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
      ),
      parsedData,
      headers,
    });
  } catch (error) {
    reject(
      new Error(
        `Data processing error: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      )
    );
  }
}

function findHeaderRowByStarterWord(
  rawData: any[],
  mapping: FieldMapping
): {
  headerRowIndex: number;
  headers: string[];
  columnMapping: { [key: string]: number };
} | null {
  // Search through the first 30 rows for the starter word
  for (let i = 0; i < Math.min(30, rawData.length); i++) {
    const row = rawData[i] as any[];
    if (!row || !Array.isArray(row)) continue;

    // Convert row to lowercase strings for comparison
    const lowerRow = row.map((cell) =>
      cell ? cell.toString().toLowerCase().trim() : ""
    );

    // Check if this row contains the starter word using stricter matching
    const starterWordIndex = lowerRow.findIndex((cell) => {
      if (!cell) return false;
      
      const cellStr = cell.toString().toLowerCase().trim();
      const starterWord = mapping.starterWord.toLowerCase().trim();
      
      // First try exact match
      if (cellStr === starterWord) return true;
      
      // Then try whole word match (word boundaries)
      const wordRegex = new RegExp(`\\b${starterWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
      if (wordRegex.test(cellStr)) return true;
      
      // Only allow substring match if the starter word is reasonably long (>3 chars)
      // and the cell doesn't look like transaction data
      if (starterWord.length > 3 && 
          cellStr.includes(starterWord) && 
          !isTransactionLikeData(cellStr)) {
        return true;
      }
      
      return false;
    });

    if (starterWordIndex === -1) continue;

    // Found the starter word, now map all columns
    const columnMapping: { [key: string]: number } = {};

    // Find each required column by exact or partial match
    columnMapping[mapping.dateColumn] = findColumnIndex(
      lowerRow,
      mapping.dateColumn
    );
    columnMapping[mapping.descriptionColumn] = findColumnIndex(
      lowerRow,
      mapping.descriptionColumn
    );

    if (mapping.amountColumn) {
      columnMapping[mapping.amountColumn] = findColumnIndex(
        lowerRow,
        mapping.amountColumn
      );
    }

    if (mapping.withdrawalColumn) {
      columnMapping[mapping.withdrawalColumn] = findColumnIndex(
        lowerRow,
        mapping.withdrawalColumn
      );
    }

    if (mapping.depositColumn) {
      columnMapping[mapping.depositColumn] = findColumnIndex(
        lowerRow,
        mapping.depositColumn
      );
    }

    if (mapping.typeColumn) {
      columnMapping[mapping.typeColumn] = findColumnIndex(
        lowerRow,
        mapping.typeColumn
      );
    }

    // Check if we found the minimum required columns
    const hasRequiredColumns =
      columnMapping[mapping.dateColumn] !== -1 &&
      columnMapping[mapping.descriptionColumn] !== -1 &&
      ((mapping.amountColumn && columnMapping[mapping.amountColumn] !== -1) ||
        (mapping.withdrawalColumn &&
          columnMapping[mapping.withdrawalColumn] !== -1) ||
        (mapping.depositColumn && columnMapping[mapping.depositColumn] !== -1));

    if (hasRequiredColumns) {
      return {
        headerRowIndex: i,
        headers: row.map((cell) => (cell ? cell.toString().trim() : "")),
        columnMapping,
      };
    }
  }

  return null;
}

function isTransactionLikeData(cellStr: string): boolean {
  // Check if the cell looks like transaction data rather than a header
  const transactionPatterns = [
    /upi-/i,                    // UPI transactions
    /\d{10,}/,                  // Long numbers (transaction IDs)
    /-[A-Z]{4}\d+-/,           // Bank codes like -ICIC0DC0099-
    /payu@|axisb@|icici/i,     // Payment gateway patterns
    /payment|transfer|loan/i,   // Transaction keywords
    /\d{2}\/\d{2}\/\d{2,4}/,   // Date patterns
    /₹\d+|\$\d+/,              // Currency amounts
  ];
  
  return transactionPatterns.some(pattern => pattern.test(cellStr));
}

function findColumnIndex(row: string[], columnName: string): number {
  const lowerColumnName = columnName.toLowerCase().trim();

  // First try exact match
  const exactMatch = row.findIndex((cell) => {
    if (!cell) return false;
    return cell.toString().toLowerCase().trim() === lowerColumnName;
  });
  if (exactMatch !== -1) return exactMatch;

  // Then try whole word match
  const wholeWordMatch = row.findIndex((cell) => {
    if (!cell) return false;
    const cellStr = cell.toString().toLowerCase().trim();
    const wordRegex = new RegExp(`\\b${lowerColumnName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
    return wordRegex.test(cellStr);
  });
  if (wholeWordMatch !== -1) return wholeWordMatch;

  // Finally try partial match, but be more restrictive
  const partialMatch = row.findIndex((cell) => {
    if (!cell) return false;
    const cellStr = cell.toString().toLowerCase().trim();
    
    // Only allow partial matches for reasonable column names
    // and avoid matching transaction-like data
    if (lowerColumnName.length > 2 && 
        !isTransactionLikeData(cellStr) &&
        (cellStr.includes(lowerColumnName) || lowerColumnName.includes(cellStr))) {
      return true;
    }
    
    return false;
  });

  return partialMatch !== -1 ? partialMatch : -1;
}

function parseTransactionRow(
  row: any,
  mapping: FieldMapping,
  index: number
): ParsedTransaction {
  try {
    // Extract date
    const dateValue = row[mapping.dateColumn];
    if (!dateValue) {
      return {
        date: "",
        description: "",
        amount: 0,
        type: "debit",
        originalRow: row,
        success: false,
        error: `No date found in column '${mapping.dateColumn}'`,
      };
    }

    const formattedDate = formatDate(dateValue);
    if (!formattedDate) {
      return {
        date: "",
        description: "",
        amount: 0,
        type: "debit",
        originalRow: row,
        success: false,
        error: `Invalid date format: ${dateValue}`,
      };
    }

    // Extract description
    const description = row[mapping.descriptionColumn]?.toString().trim() || "";
    if (!description) {
      return {
        date: formattedDate,
        description: "",
        amount: 0,
        type: "debit",
        originalRow: row,
        success: false,
        error: `No description found in column '${mapping.descriptionColumn}'`,
      };
    }

    // Extract amount and determine type
    let amount = 0;
    let transactionType: "debit" | "credit" = "debit";

    if (mapping.amountColumn) {
      // Single amount column
      const amountValue = row[mapping.amountColumn];
      amount = parseAmount(amountValue);

      if (isNaN(amount)) {
        return {
          date: formattedDate,
          description,
          amount: 0,
          type: "debit",
          originalRow: row,
          success: false,
          error: `Invalid amount in column '${mapping.amountColumn}': ${amountValue}`,
        };
      }

      // Determine type from type column or amount sign
      if (mapping.typeColumn) {
        const typeValue =
          row[mapping.typeColumn]?.toString().toLowerCase() || "";
        transactionType =
          typeValue.includes("credit") || typeValue.includes("cr")
            ? "credit"
            : "debit";
      } else {
        // If amount is negative, it's typically a debit
        transactionType = amount < 0 ? "debit" : "credit";
        amount = Math.abs(amount);
      }
    } else if (mapping.withdrawalColumn && mapping.depositColumn) {
      // Separate withdrawal and deposit columns
      const withdrawalValue = row[mapping.withdrawalColumn];
      const depositValue = row[mapping.depositColumn];

      const withdrawalAmount = parseAmount(withdrawalValue);
      const depositAmount = parseAmount(depositValue);

      // Check withdrawal column first
      if (!isNaN(withdrawalAmount) && withdrawalAmount > 0) {
        amount = withdrawalAmount;
        transactionType = "debit";
      }
      // Then check deposit column
      else if (!isNaN(depositAmount) && depositAmount > 0) {
        amount = depositAmount;
        transactionType = "credit";
      }
      // Fallback: search all numeric columns for amount data
      else {
        const allValues = Object.values(row);
        for (const value of allValues) {
          const testAmount = parseAmount(value);
          if (!isNaN(testAmount) && testAmount > 0) {
            amount = testAmount;
            // Determine type based on description or context
            transactionType = isCreditTransaction(description)
              ? "credit"
              : "debit";
            break;
          }
        }

        if (amount === 0) {
          return {
            date: formattedDate,
            description,
            amount: 0,
            type: "debit",
            originalRow: row,
            success: false,
            error: `No valid amount found in withdrawal (${withdrawalValue}) or deposit (${depositValue}) columns`,
          };
        }
      }
    } else {
      return {
        date: formattedDate,
        description,
        amount: 0,
        type: "debit",
        originalRow: row,
        success: false,
        error: "No amount column configuration found",
      };
    }

    return {
      date: formattedDate,
      description,
      amount,
      type: transactionType,
      originalRow: row,
      success: true,
    };
  } catch (error) {
    return {
      date: "",
      description: "",
      amount: 0,
      type: "debit",
      originalRow: row,
      success: false,
      error: `Parse error: ${
        error instanceof Error ? error.message : "Unknown error"
      }`,
    };
  }
}

function formatDate(dateValue: any): string {
  try {
    if (!dateValue) return "";

    // Handle Excel date serial numbers first
    if (
      typeof dateValue === "number" &&
      dateValue > 25000 &&
      dateValue < 100000
    ) {
      // Excel date serial number (days since 1900-01-01)
      const excelEpoch = new Date(1900, 0, 1);
      const date = new Date(
        excelEpoch.getTime() + (dateValue - 2) * 24 * 60 * 60 * 1000
      );
      if (!isNaN(date.getTime())) {
        return date.toISOString().split("T")[0];
      }
    }

    const dateStr = dateValue.toString().trim();

    // Handle DD/MM/YY format specifically (like 01/06/25)
    const ddmmyy = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
    if (ddmmyy) {
      const [, day, month, year] = ddmmyy;
      const fullYear = parseInt(year) <= 30 ? `20${year}` : `19${year}`;
      const date = new Date(
        parseInt(fullYear),
        parseInt(month) - 1,
        parseInt(day)
      );
      if (!isNaN(date.getTime())) {
        return date.toISOString().split("T")[0];
      }
    }

    // Handle DD/MM/YYYY format
    const ddmmyyyy = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (ddmmyyyy) {
      const [, day, month, year] = ddmmyyyy;
      const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
      if (!isNaN(date.getTime())) {
        return date.toISOString().split("T")[0];
      }
    }

    // Handle other date formats
    const formats = [
      /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/, // DD/MM/YY or DD/MM/YYYY
      /^(\d{2,4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/, // YYYY/MM/DD
    ];

    for (const format of formats) {
      const match = dateStr.match(format);
      if (match) {
        let [, part1, part2, part3] = match;

        // Determine if it's DD/MM/YYYY or YYYY/MM/DD based on first part
        let day, month, year;

        if (parseInt(part1) > 31) {
          // First part is year (YYYY/MM/DD)
          year = part1;
          month = part2;
          day = part3;
        } else {
          // Assume DD/MM/YYYY (Indian format)
          day = part1;
          month = part2;
          year = part3;
        }

        // Handle 2-digit years
        if (year.length === 2) {
          const yearNum = parseInt(year);
          year = yearNum <= 30 ? `20${year}` : `19${year}`;
        }

        // Validate and create date
        const dayNum = parseInt(day);
        const monthNum = parseInt(month);
        const yearNum = parseInt(year);

        if (
          dayNum >= 1 &&
          dayNum <= 31 &&
          monthNum >= 1 &&
          monthNum <= 12 &&
          yearNum >= 1900
        ) {
          const date = new Date(yearNum, monthNum - 1, dayNum);
          if (!isNaN(date.getTime())) {
            return date.toISOString().split("T")[0];
          }
        }
      }
    }

    // Try native Date parsing as last resort
    const nativeDate = new Date(dateStr);
    if (!isNaN(nativeDate.getTime())) {
      return nativeDate.toISOString().split("T")[0];
    }

    return "";
  } catch (error) {
    console.warn("Date parsing error:", dateValue, error);
    return "";
  }
}

function parseAmount(value: any): number {
  if (value === null || value === undefined || value === "") return NaN;

  const str = value.toString().trim();
  if (!str) return NaN;

  // Remove currency symbols, commas, and spaces
  const cleanStr = str.replace(/[₹$£€,\s]/g, "");

  // Handle parentheses as negative (accounting format)
  const isNegative = cleanStr.includes("(") && cleanStr.includes(")");
  const numStr = cleanStr.replace(/[()]/g, "");

  const amount = parseFloat(numStr);
  if (isNaN(amount)) return NaN;

  return isNegative ? -Math.abs(amount) : amount;
}

function isCreditTransaction(description: string): boolean {
  const lowerDesc = description.toLowerCase();

  const creditKeywords = [
    "salary",
    "sal",
    "wage",
    "pay",
    "deposit",
    "credit",
    "interest",
    "dividend",
    "bonus",
    "transfer in",
    "received",
    "credited",
    "incoming",
  ];

  return creditKeywords.some((keyword) => lowerDesc.includes(keyword));
}

export function exportToCSV(transactions: Transaction[]): string {
  const headers = ["Date", "Description", "Amount", "Type", "Category"];
  const csvContent = [
    headers.join(","),
    ...transactions.map((t) =>
      [t.date, `"${t.description}"`, t.amount, t.type, t.category].join(",")
    ),
  ].join("\n");

  return csvContent;
}

export function downloadCSV(
  transactions: Transaction[],
  filename: string = "transactions.csv"
) {
  const csvContent = exportToCSV(transactions);
  const blob = new Blob([csvContent], { type: "text/csv;charset-utf-8;" });
  const link = document.createElement("a");

  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", filename);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}